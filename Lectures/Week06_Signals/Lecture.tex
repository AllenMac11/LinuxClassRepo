\documentclass[12pt]{article}
\usepackage[breaklinks=true]{hyperref}
\usepackage[margin=1in]{geometry}

\usepackage{color}
\usepackage{graphicx}

\definecolor{pblue}{rgb}{0.13,0.13,1}
\definecolor{pgreen}{rgb}{0,0.5,0}
\definecolor{pred}{rgb}{0.9,0,0}
\definecolor{pgrey}{rgb}{0.46,0.45,0.48}

\usepackage{listings}
\lstset{language=bash,
  showspaces=false,
  showtabs=false,
  breaklines=true,
  showstringspaces=false,
  breakatwhitespace=true,
  commentstyle=\color{pgreen},
  keywordstyle=\color{pblue},
  stringstyle=\color{pred},
  basicstyle=\ttfamily,
  frame=single,
  moredelim=[il][\textcolor{pgrey}]{$$},
  moredelim=[is][\textcolor{pgrey}]{\%\%}{\%\%}
}

\lstdefinestyle{term}{language=bash,
  columns=fullflexible,
  showspaces=false,
  showtabs=false,
  breaklines=true,
  showstringspaces=false,
  tabsize=2,
  breakatwhitespace=true,
  commentstyle=\color{pgreen},
  keywordstyle=\color{pblue},
  stringstyle=\color{pred},
  basicstyle=\small\ttfamily,
  frame=single,
  moredelim=[il][\textcolor{pgrey}]{$$},
  moredelim=[is][\textcolor{pgrey}]{\%\%}{\%\%},
  upquote=true
}
\lstdefinestyle{sh}{language=bash,
  columns=fullflexible,
  showspaces=false,
  showtabs=false,
  breaklines=true,
  showstringspaces=false,
  tabsize=2,
  breakatwhitespace=true,
  commentstyle=\color{pgreen},
  keywordstyle=\color{pblue},
  stringstyle=\color{pred},
  numbers=left,
  stepnumber=1,
  basicstyle=\small\ttfamily,
  frame=single,
  moredelim=[il][\textcolor{pgrey}]{$$},
  moredelim=[is][\textcolor{pgrey}]{\%\%}{\%\%},
  upquote=true
}

\lstdefinestyle{py}{language=python,
  columns=fullflexible,
  showspaces=false,
  showtabs=false,
  breaklines=true,
  showstringspaces=false,
  tabsize=2,
  breakatwhitespace=true,
  commentstyle=\color{pgreen},
  keywordstyle=\color{pblue},
  stringstyle=\color{pred},
  numbers=left,
  stepnumber=1,
  basicstyle=\small\ttfamily,
  frame=single,
  moredelim=[il][\textcolor{pgrey}]{$$},
  moredelim=[is][\textcolor{pgrey}]{\%\%}{\%\%},
  upquote=true
}

\lstdefinestyle{txt}{
  columns=fullflexible,
  showspaces=false,
  showtabs=false,
  breaklines=true,
  showstringspaces=false,
  tabsize=2,
  breakatwhitespace=true,
  numbers=left,
  stepnumber=1,
  basicstyle=\small\ttfamily,
  frame=single,
  moredelim=[il][\textcolor{pgrey}]{$$},
  moredelim=[is][\textcolor{pgrey}]{\%\%}{\%\%},
  upquote=true
}


\title{\textbf{Week 06} \\
\Large Signals, C Programs, SetUID, SetGID, and Fun Stuff }
\author{
	Melvyn Ian Drag
}
\date{\today}


\begin{document}
\maketitle

\begin{abstract}
We'll learn about signal handling, C Programs, ssh, setuid, setgid, and talk about the exam.
\end{abstract}

\section{Machine Configuration 7:00 - 7:15}
For this lecture we will be using a \textbf{Debian 10 Digital Ocean server}.
Make sure you have one. Also, when you start the server, run the following
commands to make sure you can complete the exercises in this document.

\begin{lstlisting}[style=term]
root@machine$ apt update
root@machine$ apt install python3-dev vim git
# if prompted, say yes to everything.
root@machine$ git clone https://github.com/melvyniandrag/LinuxClassRepo.git
# now you have all the class stuff
\end{lstlisting}

{\Large Hurry and do this now! Don't ask me how to install python3 a half hour
from now. Don't ask how to clone the class repo at 8PM! It is important that you
keep up as we have alot to cover today!}

\section{Intro 7:15 - 7:20}

\textit{Start a podcast on Android phone, have someone call me during while the
podcast is playing and show that Android stops the podcast and starts the phone
call. When we hang up what happens? Either the podcast will start again or it
will not, this depends on how the phone is programmed.}

In \*nix a common thing you do is send signals to processes. You will sometimes
want to send information to a running program to make it do things. To get an
idea of what a signal is, imagine you are watching a youtube video on your
cell phone. If a phone call comes in, the video will pause, the phone app will
be opened, and you will be prompted to accept the call ( Other phones may
handle the situation differently, this is just a simple example ). How does your
phone ( which is a computer ) do this? I don't know, but in general when you
want to communicate with a running program you use signals. Maybe Android uses
signals when it makes programs communicate, maybe it doesn't.

 Signals are one important way we do \textbf{Interprocess Communication ( IPC )} on
Linux/BSD/Unix. The most common signals you'll want to send as an everyday Linux
user are \textbf{SIGINT} and \textbf{SIGTSTP}

\section{7:20 - 7:35 SIGTSTP and SIGINT}

\textit{The programs used throughout this lecture are in the Week06 Lecture directory in
the class repository that we  cloned at the beginning of class. }

\subsection{SIGINT}
We'll see what these do by running a small python program. Create this program
and run it on your computer ( note you don't need to create this program if you
have the class repo - it's there in the week 06 lecture directory ):

\lstinputlisting[language=Python]{runForever.py}

You run the program by typing:

\begin{lstlisting}[style=term]
root@machine$ python3 runForever.py
# the prompt will become unresponsive as the python program runs.
\end{lstlisting}

This program will run forever and hog up our terminal. How do we make it stop? We can send the \textbf{SIGINT} signal by typing "CTRL+C". Note that it stops. 

That may have been your first Python program. If you want to do the same thing
with bash, try running this program and seeing that it is ended with CTRL+C:

\lstinputlisting[language=bash,caption={runForever.sh}]{runforever.sh}

You have to ways to run this program:

\begin{lstlisting}[style=term]
user@machine$ bash runforever.sh
# interesting output
# end it by typing CTRL+C
\end{lstlisting}

Or you can use the "executable" permission I showed last week:

\begin{lstlisting}[style=term]
user@machine$ chmod +x runforever.sh
user@machine$ ./runforever.sh
# interesting output
# end it by sending the SIGINT signal with CTRL+C
\end{lstlisting}

{\Large Question for class: do you remember another way to make the script
executable? How to do it with numbers? e.g. chmod 700 or chmod 777 or chmod 500,
etc.}

\subsection{SIGTSTP}
Another thing you might want to do is just pause the program for a bit. We saw
sometihng like this with Android already - if you receive a phone call, the
podcast application is paused, not closed. In Linux you pause a program by sending it 
a \textbf{SIGTSTP}. This is done by typing CTRL+Z. To restart the program that you
 paused you can send it a \textbf{SIGCONT} command. To send a \textbf{SIGCONT}
 command is a little different. There is no keyboard shortcut like CTRL+XYZ to
send the SIGCONT signal. You must type:

\begin{lstlisting}[style=term]
user@machine$ kill -18 $PYTHON_PID # where $PYTHON_PID is the PID of the process you stopped.
\end{lstlisting}

To verify this works, run the python program, but this time stop and restart it
in the following way:

\begin{lstlisting}[style=term]
user@machine$ python3 runForever.py
# running 
# then type CTRL+Z
# should say the process was stopped.
user@machine$ pidof python3
1123 1345 7899 9999
# a list of numbers comes out - these are all the python processes on your
# computer. We want to restart the newest one, the one that you just stopped.
# The smaller numbers are programs that Linux is running for some reason or
# other.
# Dont worry about those. In this example, the stopped process id ( pid
# ) is 9999. 
user@machine$ kill -18 9999
user@machine$ jobs
[1] Stopped        python3 runForever.py
user@machine$ fg 1
# you will see the python process come to life.
# Do this a few more times until bored. Then type CTRL+C to kill the process
# with SIGINT once and for all.
\end{lstlisting}

\subsection{Verify the signals}
See figure ~\ref{fig:pythonsignals} for a screenshot of me running these
commands.

\begin{enumerate}
\item type \textit{pidof python} ( or \textit{python3} )
\item Run \textit{runForever.py}
\item Send \textbf{SIGINT} with the keyboard
\item type \textit{pidof python} ( or \textit{python3} )
\item There should be no pid there corresponding to your process.
\item Run \textit{runForever.py}
\item Send \textbf{SIGTSTP} with the keyboard
\item type \textit{pidof python} ( or \textit{python3} )
\item There \textbf{should} be a pid corresponding to your process.
\item Restart the process with \textit{kill -18 \$ PID}
\item Type \textit{jobs}
\item Type \textit{fg \$JOB\_ID}
\item Kill the process so it doesn't hog memory.
\end{enumerate}

\begin{figure}[ht]
	\centering
	\includegraphics[width=0.7\textwidth]{signals.png}
	\caption{Look at home I send to python3}
	\label{fig:pythonsignals}
\end{figure}

\section{7:45-7:50 jobs vs processes}
Note I used the \textit{jobs} command above. That command lists the processes started by the current shell. If you start a new shell and type \textit{jobs} there will be no output, because your new shell didn't do anything yet.
There are two similar things happening here. The commands I've been using a bit
are \textit{pidof} and \textit{jobs}, and they both seem to report back some
number corresponding to a running program. All running programs are processes,
and they all get a system-wide \textit{pid} ( as always I'm not 100\% sure what
that stands for. \textit{process identifier} ? Or maybe \textit{process
identification} ? Whatever, pid is good enough). Every program that has been
started in the current bash session gets a job id tied to it. This job id will
not be visible to other bash sessions. The pid will be visible to everyone,
however.

Remember:
\begin{itemize}
\item all running programs are called processes and have a pid
\item all running programs are called processes and have a pid
\item all running programs are called processes and have a pid
\item all running programs are called processes and have a pid
\end{itemize}

never forget:

\begin{itemize}
\item all programs started by my shell are called jobs and have a job id.
\item all programs started by my shell are called jobs and have a job id.
\item all programs started by my shell are called jobs and have a job id.
\item all programs started by my shell are called jobs and have a job id.
\end{itemize}

\section{ kill }
You use the \textit{kill} command to send a signal to a process. Did you read
that last sentence? If you go on a job interview and the interviewer asks you:

\begin{verbatim}
Hello job candidate, do you know how to send a signal to a process on Linux?
\end{verbatim}

You had better know how to answer. I showed you one example wherein we sent an 18 to a process. You can see all of the signals available to send by typing 

\begin{lstlisting}
user@machine$ kill -l
\end{lstlisting}

You will see in the list are two of the signals I already showed you - the ones
I called `the most important signals'. Those are SIGINT and  SIGTSTP. Ask the
lass what the corresponding numbers are. These signals are known by the numbers
you just told me, SIGINT, INT, SIGTSTP and TSTP. The signal
18 is also known as SIGCONT or simply CONT. 
Using the kill command you can send these signals in three ways:

\begin{itemize}
\item Using the signal name e.g \textbf{CONT}
\item Using `SIG' + the signal name e.g. \textbf{SIGCONT}
\item Using the numeric code for the signal e.g. 18
\end{itemize}

In this lecture we're going to focus on the following signals:

\begin{enumerate}
\item SIGINT
\item SIGKILL
\item SIGTERM
\item SIGSTOP
\item SIGTSTP
\end{enumerate}

though there are more signals, this should be enough to get you started. And if you want to learn more you of course can go get a book. We're going to look at when you use each one of the above and how programs handle them when they are received. I think these are the most interesting of the 64 signals.

Let's test the signals

\begin{lstlisting}
user@machine$ python3 runForever.py & # ampersand puts it in the background
user@machine$ jobs
[1]+Running   python3 runForever.py &
user@machine$ kill -20 %1 # or kill -20 $PIDOF_PYTHON. kill takes job ids or pids
user@machine$ jobs
#stopped
user@machine$ kill -18 %1
user@machine$ jobs
# it's running again
user@machine$ fg 1
user@machine$ [type ctrl + z]
\end{lstlisting}

We just sent \textbf{SIGCONT} and \textbf{SIGTSTP} using the numeric codes for them. Remember that we got the numeric codes by looking at the output of \textit{kill -l}. You'll note that, while the command is called \textit{kill}, it does more than kill. It can send all kinds of signals.

There is a signal related to \textbf{SIGTSTP} called \textbf{SIGSTOP}.
The difference between them is that \textbf{STOP} cannot be ignored and typically comes from a program. \textbf{TSTP} can be ignored. Depending on how much you've used linux, you may or may  not have been in a situation where you were mashing \textit{CTRL+C} over and over again, but the program wouldn't stop! By the end of tonight we'll write some code showing how that happens. Just know, that by the design of the Linux OS, \textbf{STOP} signals cannot be ignored.

\begin{lstlisting}
user@machine$ python runForever.py &
user@machine$ jobs
[1]+ Running python runForever.py &
user@machine$ kill -STOP %1
user@machine$ jobs
# it's stopped
user@machine$ kill -18 %1
user@machine$ jobs 
# it's running
user@machine$ fg 1
user@machine$ [type ctrl + z]
\end{lstlisting}

\section{An example of a pesky program}
Before I told you that there are programs that just won't stop. Even though you
say SIGINT, the program will ignore you. Here is an example of such a program. I
use a tool called pdflatex to compile the \LaTeX source code for these lecture
notes into pretty pdfs for you. The \LaTeX compiler will refuse to respond the
the CTRL+C command when you try to make it stop.

TODO show students how to install pdflatex, get them a little sample .tex file
to compile, and show them how the compiler, when it encounters a bug in the
source code, will not exit even if you say CTRL+C.

\section{fg and bg}
You'll note I've used \textit{fg} a bit. This command takes a job id and puts it in the foreground. When you continue a job with \textbf{SIGCONT} it starts in the background. You have to bring it back into the foreground with \textit{fg} so you can interact with it e.g. send it a \textbf{SIGINT}. \textit{bg} has the opposite effect of putting a job in the background, like we did with \textit{\&}

\section{INT, TERM, KILL}
\textbf{INT} is sent when you hit `CTRL+Z` on your keyboard. It interupt the
process and makes it stop. `SIGINT` can also be sent will \textit{kill}.
\textbf{SIGTERM} and \textbf{SIGINT} are approximately the same thing,
differences in their behavior are left up to the application developer. I'll
show you more about this later when we write some little C programs that will
ignore signals. You should now send \textbf{INT} and \textbf{TERM} to the \textit{runForever} program and you will see that both end the process. \textbf{KILL} is like \textbf{INT} or \textbf{TERM} but it cannot be ignored.

The number for KILL aka SIGKILL is 9. Remember, this signal cannot be blocked or
ignored. You can always send signal -9, no matter what is happening this signal
will work. It cannot be blocked or ignored! In any Linux system administration
book you read you will see thei \textbf{warning: `NEVER USE -9!`}. We have just
seen that processes can deliberately ignore or block signals if interruption
would cause some serious system harm. But sometimes, we just want the darned
process to stop! You can use SIGKILL under very dire circumstamstances, because
issuing this signal could cause file corruption!

Actually, thats what they say. I use \textbf{SIGKILL} sometimes and don't worry about it. My reason for doing so is boring to explain. I encourage you to read the following posts to develop your own opinion of whether or not to use SIGKILL/KILL/9

\begin{itemize}
\item \url{https://www.reddit.com/r/linux/comments/4b1mwh/do_not_use_sigkill/}
\item \url{https://unix.stackexchange.com/questions/281439/why-should-i-not-use-kill-9-sigkill}
\item \url{http://turnoff.us/geek/dont-sigkill/}
\item \url{https://unix.stackexchange.com/questions/8916/when-should-i-not-kill-9-a-process}
\end{itemize}

Whether you use the following code or not in your daily life, on your own laptop . . .

\begin{lstlisting}
user@machine$ kill -9 $pid
\end{lstlisting}

when you are in the office make sure you use \textbf{SIGINT} and \textbf{SIGTERM} first or your colleagues might look down on you as a reckless person.

\section{{\color{red} EXERCISE: C Programming Warmup + A Break}}
{\color{green} Allow students to go to bathroom, talk amongst themselves for a
few minutes. The task during these few minutes is to get the helloworld.c file
using wget or whatever other means they want, then compile and run it as shown
below. After the break we'll move on to the signal handlers}.

We are going to write some C programs now. C is a language that is very intimately related to Linux. It looks and feels somewhat like other languages like 
\begin{enumerate}
\item Java
\item C\#
\item C++
\item But has many similarities to others. . .
\end{enumerate}

So if you have any experience with those languages, you'll more or less be able to read C.
Example program:

\lstinputlisting[language=C]{helloworld.c}

To compile and run this code you need to install the C compiler gcc, and then
compile and run the code.:

\begin{lstlisting}
user@machine$ sudo apt update
user@machine$ sudo apt install build-essential
user@machine$ gcc helloworld.c -o helloworld # compile the code
user@machine$ ./helloworld # run the code
\end{lstlisting}

\section{Writing Custom Signal Handlers With C}

We will change the behavior now. Run the code. From a separate terminal window, send kill signals. Then inspect the return code of the running process and see how we customized the return valu based on which signal we received. Remember that in our first assignment we looked at \$? to see how a program ended. You can return different values not just fro mbash scripts, as we've done with `return` and `exit` statements up until now. Your software can be programmed to return values too.

Returning to our discussion of signals, signals can be caught,  ignored, or blocked.

Most important thing for these three samples

{\LARGE GO SLOOOOOOOOW}

{\LARGE Open two Terminals and show how you send various signals to the process using \textit{kill}}

{\LARGE When appropriate ( i.e. TSTP or INT ) also show you can use CTRL+C and CTRL+Z}

\subsection{01\_signal\_handler.c}
This code shows the Linux programs can choose how to handle signals.

We will change write come code to change signal handling behavior now. Open `01*.c` on your computer and have a look at it. This is a small C program that registers two signal handlers. Remember, all these linux command line tools we are using like mv, cp, etc. are all simple C programs like the one we are writing now. They all register signal handlers like we are going to do now, and that's how the programs know what to do when you type CTRL+C or CTRL+Z on the keyboard, or what to do when you send a command with \textit{kill}

\begin{center}
\textbf{modify the program, compile, run. Allow students a few minutes to change the messages returned by SIGINT and SIGTERM. }
\end{center}

\lstinputlisting[language=C]{SignalHandlers/01_signal_handler.c}
\subsection{How to compile?}
Go to the SignalHandlers directory and type:

\begin{lstlisting}
user@machine$ gcc 01_signal_handler.c -o 01.out #compile
user@machine$ ./01.out #run
\end{lstlisting}

\subsection{02\_ignore.c}
This example shows that we can ignore a signal! We can tell a program to ignore a signal. 

What happens if you tell a program to ignore a signal that is unignorable?
\lstinputlisting[language=C]{SignalHandlers/02_ignore.c}

\subsection{03\_block.c}
This example shows that programs can temporarily refuse to handle signals. This is done with blocking. This program temporarily blocks a signal - can you see which one?

Try to send the signal while it is blocked and see what happens!!

\lstinputlisting[language=C]{SignalHandlers/03_block.c}

\section{Summary}

What can happen with signals?

\begin{itemize}
\item They can be handled
\item They can be ignored
\item They can be blocked
\end{itemize}

\section{What are signals?}
Signals are a form of interprocess communication used in Linux. There are many interprocess communication mechanisms, this is just one of them. If you've never heard of IPC, just know it is all around you when you are using computers. For example, consider the case when you are on your telephone and you're listening to music. When a phone call comes in, the music is probably paused and the phone app is brought up on the screen. The operating system on your phone needed an IPC mechanism to detect that the phone process was in some active state and that other interfering processes need to take action while the call is active. Depending on how the software is written on your phone, the music might resume playing when you hang up, and the music app might come to the foreground on your screen. Or maybe it stays paused and you have to manually reopen the app and hit 'play' again. Or maybe something else happens.

IPC might also be used if you have two processes on a device - maybe you have one process listening for radio transmissions and another on that turns a motor. If the radio receiver receives a signal, maybe you want another process to turn a motor and open your garage door or something.

There are many ways to do IPC, even on Linux there are a bunch of IPC mechanisms. Signals is just one of them.

\section{Discussion of homework}
Look at the cool shell scripts book. I told you about signal handlers today.
Then I showed you how to do signal handling in C. Then I showed you how various
programs handle various signals. Now I want you to read a little article I found
online that explains how to handle signals in bash, and I want you to write some
code. The article may be gone from the internet. 

If you look here:

\url{linuxjournal.com} you'll see a notice that the company is dead, there
wasn't enough money to support the magazine. So the articles are on the internet
until they don't feel like paying for the webserver anymore. That could happen
at any moment. Very sad that they couldnt get enough money to stay afloat, the
magazine had many good articles. 

Anyway, the one you need to read is / was here:

\url{https://www.linuxjournal.com/article/10815} 

and in the event that it disappears it's in the Homework/Week06\_XX directory of
this repo.

You must read that article 

\section{SetUID and SetGID}
\subsection{TL;DR}
In the next few minutes we're going to write a program that you can run as a non-root user and delete  files belonging to root. This shouldn't happen! But it can if you know this cool trick. 

\subsection{Introduction}
There are some special permissions that can be assigned to executables in Linux. You can trick your operating system into running a process as root, even though you are not root. The idea being, maybe you have a very trusted program that needs to do some root stuff. You are absolutely sure that the root stuff it does will not destroy your system, so you want to allow other users to do the root stuff even though they aren't root. <Flesh this out with some more discussion until it is clear>. 
  
\subsection{war story}
Show Sparcus.com

A use case that I had was I wrote a very secure docker container and wanted anyone to be able to build and launch it, connected to a few system resources. I needed root permissions to make this happen, but I didn't want to drop into root all the time I wanted to do this safe thing, so I wrote a little program that would do some "rootly stuff", set the permissions and ownership of the file appropriately, and now I can run it as an unprivileged user.

If you call setuid(0) in your program, it changes you to the root user from the eyes of the operating system and lets you do rootly stuff.

\subsection{uid}
In Linux, all users have a user id. You can get your user id from the command line by typing `id`. We haven't talked about this uid yet, and we certainly haven't used it, but it has been there all along. Today we will see what it is and we'll use it.

Try this:
\begin{lstlisting}
$ id
[your id]
$ sudo su -
$ id
[you see user id is 0]
\end{lstlisting}

So now we know what the uid of the root user is. Check out this program


\lstinputlisting[language=C]{setuid_setgid/example.c}

We see that with this program we make a few calls to getuid() and a few calls to setuid(). You don't have to worry too much about this program - if you don't know C it will maybe scare you a bit. That's why I've chosen this simple and illustrative program.  The main idea is that you see some source code here that calls these mysterious functions getuid() and setuid()! We can change our user id while the program is running to trick the computer into thinking you are root!

`getuid` returns the user id of the user running the program.


We will first compile this normally and run it. You will see it fails and it exits with the value 1.

\begin{lstlisting}
$ gcc setuid.c -o setuid
$ ./setuid
...
error msg
$ echo $?
1
\end{lstlisting}

To make this work, we will have to change the ownership, the group, and the permissions.

\begin{lstlisting}
$ sudo chown root:root setuid
$ sudo chmod +s setuid
$ ls -l setuid
$ ./setuid
\end{lstlisting}

So you see that both user and group have an `s` where there used to be an `x`. This means that the program can setuid() and setgid(). For this example we only wanted to setuid(), so we can just set u+s.

\begin{lstlisting}
$sudo chmod g-s setuid
$ls -l setuid
$./setuid
\end{lstlisting}

Notice if we make group have `+s` but take the privilege away from user, 

\begin{lstlisting}
$sudo chmod u-s,g+s setuid
$ls -l setuid
$./setuid
[fails]
\end{lstlisting}

Also, rememberwhen we were setting permissions using the octal notation? You can do that for this as well. There is no setAllID, there isonly setuid and setgid
So set uid is a 4, setgid is a 2, but what does the 1 correspond to? Not a big deal, I'll leave it here for you to read if you're curious! https://askubuntu.com/questions/432699/what-is-the-t-letter-in-the-output-of-ls-ld-tmp . So getting back to octal numbers and setuid/setgid we can set the permissions to r-sr-xr-x by saying `chmod 4555`. We can set the permissions to `r-xr-sr-x` with `chmod 2555`. Etc.

\section{Homework}
Discuss the homework in detail

\section{Exam}
Discuss the exam in detail

\section{Show Reading Materials}
If time, have class  download the vim book. Make them skim it and learn something. They can all leave after they've learned and showed me they've learned 3 things about vim.

\end{document}
